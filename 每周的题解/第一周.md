# 题解

## 3. 无重复字符的最长子串|中等、高频

- [ leetcode](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

### 解题思路

最长子串——看到这两个关键字你就要想到滑动窗口，那么这道题就是窗口大小无限制的滑动窗口~ 滑动窗口具体控制就是双指针啦

然后需要求得的就是 满足条件（不含重复字符）的窗口中，最大的窗口。

- 用一个 set 存储窗口内的元素
- 当窗口内没有重复字符时就不断地向右边扩张

  - 新的右边界字符存入 set

- 出现重复后就缩小左边的窗口

  - 左边界限向右移动

- 直到最右边界限

### 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    const set = new Set();//记录窗口内元素是否出现过
    let i = 0, j = 0, res = 0;//左右指针、答案
    if(s.length == 0)return 0;//特殊情况
    while(j < s.length){//右边界小于字符串长度
        if(!set.has(s[j])){//set中没有
            set.add(s[j]);//放入set中
            res = Math.max(res, set.size);//看看答案要不要更新
        }else{//set中已经有了
            while(set.has(s[j])){//右移左边界直到没有重复字符
                set.delete(s[i]);
                i++;
            }
            set.add(s[j]);//将右边界字符加入
        }
        j++;//无论如何右边界都是一直走的
    }
    return res
};

```

## 20. 有效的括号|简单、高频

### 解题思路

括号问题，常考的就是栈的运用与操作了~

遍历字符串s

- 拿到左括号：
  - 压入栈中

- 拿到右括号，分类讨论：

  - 栈不为空：

    - 栈顶为对应的左括号：取出栈顶，继续遍历

    - 栈顶不是对应的左括号，`return false`

  - 栈为空: 直接`return false`

遍历完之后，如果栈中还有括号，就说明有左括号没有右括号来与之配对，`return false`



扩展：

也可以通过设置计数器变量存储左右括号出现次数来进行判断



pps：只有一种括号类型的时候才可以使用计数器这个方法:`（（））`，如果不止一种括号，可能就会有些样例过不了，所以这个方法是无效的，例如这种示例4`([)]'`，没有以正确的顺序闭合。



⭐：

- 栈的操作

- JS中的数组中的push、popAPI 就可以模拟栈



### 代码



```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    const stk = [] //数组模拟栈
    const mp = new Map()////对应括号映射
    mp['(']=')'
    mp['{']='}'
    mp['[']=']'
    for(let c of s){
        //拿到左括号
        // if(['(','[','{'].indexOf(c) != -1){
        if(c in mp){
            stk.push(c)
        }else {
            const top = stk.pop()
            if(c !== mp[top]) return false //栈顶不是对应的左括号或者为undefined
        }
    }
    if(stk.length)return false
    return true//一切都恰当
};
```



## 4. 寻找两个正序数组的中位数|困难、低频

### 解题思路

#### 不完全暴力

双指针分别从两个数组A、B起始位开始

1. 如果 `A[i] <= B[j]` , 则把 `A[i]` 放入新的数组中,i 往后移一位,即 i++ .

2. 如果` A[i] > B[j] `, 则把 `B[j]` 放入新的数组中,j 往后移一位, 即 j++ .

3. 计数器cnt，每次任意指针++时都++

4. 重复，直到 `cnt == (n+1)/2`，即到达中位数之地



虽然比起完全合并优化了一些，小于`O(n+m)`，但没有达到`O(log(n+m))的要求`

#### 二分查找

⭐：

1. 两个有序数组合并后，一个数组中本身的相对位置并不会变

2. 有序——二分查找

3. 对小的那个数组进行二分，确定一个 i，自然就能得到 j，因为最后的找到中位数的情况就是 `i(i+1) + (j+1) == (m + n + 1) / 2`

其中m、n分别两个数组的大小

具体来说，就是最后的情况满足`len(Aleft)+len(Bleft)=(m+n+1)/2`，并且满足` (maxLeftA <= minRightB && maxLeftB <=minRightA)`，也就是最终为下图这样的形式：

![image.png](https://pic.leetcode-cn.com/1652693635-ONmbLU-image.png)



那么要怎么到达这样的形式呢

对小的那一个数组进行二分查找，不满足就调整，具体怎么调整看代码，直到调整到满足条件



最终复杂度为`O(min(m,n))`

 

![image.png](https://gitee.com/okkjoo/image-bed/raw/master/imgs/1652693618-TwYBOu-image.png)

### 代码



```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    //对数组长度较短的那个进行二分查找操作
    nums1.length > nums2.length && ([nums1, nums2] = [nums2, nums1])
    const m = nums1.length, 
          n = nums2.length
    let low = 0, high = m 
    //二分
    while(low <= high){
        const i = low + Math.floor((high - low) / 2), //i:数组A中 minRightA 的下标
              j = Math.floor((m + n + 1) / 2) - i     //j:数组B中 minRightB 的下标  
        //这里注意特判，在边界的时候为了满足下面的条件，left的就是负无穷，right那头就是正无穷
        const maxLeftA = i === 0 ? -Infinity : nums1[i-1],
              minRightA = i === m ? Infinity : nums1[i]     
        const maxLeftB = j === 0 ? -Infinity : nums2[j - 1],
              minRightB = j === n ? Infinity : nums2[j]     
        //进行判断
        if(maxLeftA <= minRightB && maxLeftB <= minRightA){
            return (m + n) & 1 //m+n 的奇偶情况分量讨论
                ? Math.max(maxLeftA, maxLeftB)
                : (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB))/2
        }//不满足的话就要根据情况调整 low / high 指针
        else if(maxLeftA > minRightB){
            high = i - 1
        }else {
            low = low + 1
        }
    }
};
```

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)|简单、高频

### 解题思路

#### 暴力
最容易想到的就是两层for来遍历，得到满足条件的两个整数
没什么好说的，也当然是必须优化的
时间O(n^2)，空间O(1)
#### Map
用 Map 记录遍历过的值以及对应下标，同时当前遍历到的值为 value，判断（ target - value） 是否记录过在Map 中

⭐：
- 求和 --> 求差
- Map 记录值与下标的映射
- 空间换时间

 时间O(1),空间O(n)

### 代码

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
	const mp = new Map();
	for (let i = 0; i < nums.length; i++) {
		const v = nums[i];
		const diff = target - v;
		if (mp.has(diff)) return [mp.get(diff), i];
		mp.set(v, i);
	}
};

```

## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)|简单、高频

### 解题思路

#### 暴力
没做过的第一个想法肯定是将num2放到num1后面，然后再一起进行排序

但这显然就用不到两个数组一开始就是有序的特征了

#### 归并排序
复习一下归并排序的步骤：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

关键在于第三步~
比较两个数组头元素然后将较小的推至最终数组，并将其从原数组中吐出去，不断循环，直到两个数组都为空

但值得注意的是 题目圆球 不返回一个新数组，而是存储再数组num1中，也就是要求原地修改，不能申请多的空间~  为此，题目里说了 num1 的初始长度为 m+n，后n个元素为0

那么我们可以从后往前比较，从后面插入即可，用三个指针模拟
- cur：记录当前到那个位置
- m：记录 num1 数组处理到哪里
- n：记录 num2 数组处理到哪里

时间复杂度O(n) 空间复杂度O(1)

### 代码

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    let cur = m + n - 1 //从nums1尾部开始
    while(cur >= 0){
        if(n===0)return //num2已经全部放入num1中了
        if(m < 1){//num1指针先走完了
            nums1[cur--] = nums2[--n]
            continue
        }
        if(n < 1){//num2指针先走完了
            nums1[cur--] = nums1[--m]
            continue
        }
        //取较大的插入 nums1 的末尾、更新对应的指针
        if(nums1[m - 1] > nums2[n - 1]){
            nums1[cur--] = nums1[--m]
        }else {
            nums1[cur--] = nums2[--n]
        }
    }
};

```

## [415. 字符串相加](https://leetcode.cn/problems/add-strings/)|简单、高频

### 解题思路

#### 直接模拟
对两个非负整数进行 竖式计算 的模拟即可
将相同数位对齐，从低到高逐位相加，如果当前位和超过 1010，则向高位进一位
双指针从数的末尾即最低位开始，逐位相加，记录进位到 add 变量中
较少位的那一个数就在前面补零

⭐：

- `num1.charAt(i) - '0'`将一个数字字符转为数字
- 最后要`reverse`才是正确顺序的结果
- 再用`join`将数组转为字符串

时间复杂度O(n)，空间复杂度O(1)

### 代码

```js
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function(num1, num2) {
    let i = num1.length - 1, 
        j = num2.length - 1
        add = 0
    const ans = []
    while(i >= 0 || j >= 0 || add > 0){
        const a = i >= 0 ? num1[i].charAt() - '0' : 0,
              b = j >= 0 ? num2[j].charAt() - '0' : 0
        const res = a + b + add
        ans.push(res % 10)
        add = Math.floor(res / 10)
        i--,j--
    }
    return ans.reverse().join('')
};
```

## 165. 比较版本号|中等、高频

### 解题思路

#### 最方便的字符串切割

利用 `split('.')`将版本号字符串切割为数组，从下标为0开始依次比对：

时间复杂度O(n)，空间复杂度O(n)

```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function(version1, version2) {
    const v1 = version1.split('.')
          v2 = version2.split('.')
     for (let i = 0; i < v1.length || i < v2.length; ++i) {
        let x = 0, y = 0;
        if (i < v1.length) x = parseInt(v1[i]);   
        if (i < v2.length) y = parseInt(v2[i]);  
        if (x !== y)return x > y ? 1 : -1;
    }
    return 0;
};
```

#### 空间优化

我们可以不降其切割后放入数组再进行逐一比对，而是在切割时就进行逐一比对

### 代码

```js
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
var compareVersion = function (version1, version2) {
	const n = version1.length,
		m = version2.length;
	let i = 0,
		j = 0; //双指针
	while (i < n || j < m) {
		let a = 0, b = 0; //同一下标下的两个修订号
		for (; i < n && version1[i] !== "."; ++i) {
			a = a * 10 + version1[i] - "0";
		}
		++i; // 跳过点号
		for (; j < m && version2[j] !== "."; ++j) {
			b = b * 10 + version2[j] - "0";
		}
		++j; // 跳过点号
		if (a !== b) return a > b ? 1 : -1;
	}
	return 0;
};

```

## 70. 爬楼梯|简单、中频

### 解题思路

#### 动态规划

f(x) 表示爬到第x级阶梯的方案数，由每次可走一步或两步可知

- 转移条件为：`f(x)=f(x-1)+f(x-2)`
- 初始化：`f(0)=1、f(1)=1`，到第0级和第1级的方案数都是1

那么我们对`f[]`数组从2开始的遍历即可

```js
for(let i = 2; i <=n; i++){
    f[i] = f[i-1] + f[i-2];
}
return f[n]
```

这样的时间复杂度和空间复杂度都是`O(n)`

我们发现，`f(x)`只与`f(x-1)`和`f(x-2)`有关，也就是与`f(x-2)`之前的东西再无瓜葛，最后要求的结果也只是`f(x)`再利用滚动数组思想优化一下：直接用三个变量存储关键的东西就行了

```js
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};
```

现在时间复杂度为O(n)，空间复杂度为O(1)

但这种dp的入门题，还用dp就有点low了（卷，就嗯卷）

### 矩阵快速幂

用这个方法需要对线性代数有了解，但如果只是想看懂我的题解的话，也不需要特别多

- 矩阵乘法：一句话总结，就是矩阵C 内第1行第1列的元素 = 矩阵A第一行元素 与 矩阵 B第一列元素**对应各项相乘再累加**后得到的

也算有关于数论吧

快速幂

```cpp
//a^n
while(n>0)
{
    if(n&1) res*=a;
    n>>=1;
    a=a*a;
}
```

对于n次幂，对n二进制话，二进制位上位1 的话就相乘，然后一直将n右移

#### 什么时候可以用矩阵快速幂

矩阵快速幂的使用相较于dp可能没那么好看出来——也可能只是我相比这个来说dp比较熟悉

- 问题可转换为求解矩阵的n次方
  - 结合快速幂优化效率
- 递归式形如齐次线性递推式
  - 就可以构造出矩阵n次方再乘一个列向量a得到一个列向量b，且列向量b中包含我们需要的f(x)
- 递归式可以转换为齐次线性递推式

这道题目中的转移条件`f(x)=f(x-1)+f(x-2)`就是上面的第二种情况：递归式形如其次线性递归式

这个方法的时间复杂度为O(logn)

**如果你觉得难的话，其实只学dp也行，这个方法讲个思路应该也不错了...**

### 代码

最终代码如下：

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    const q = [[1, 1], [1, 0]];
    const res = pow(q, n);
    return res[0][0];
};

const pow = (a, n) => {
    let ret = [[1, 0], [0, 1]];
    while (n > 0) {
        if ((n & 1) === 1) {
            ret = multiply(ret, a);
        }
        n >>= 1;
        a = multiply(a, a);
    }
    return ret;
}

const multiply = (a, b) => {
    const c = new Array(2).fill(0).map(() => new Array(2).fill(0));
    for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
        }
    }
    return c;
}
```



