# 带你用JS 刷高频面试算法题|第一周|okkjoo-leetcodeHot-byJs

`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 每周日更新~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)

这是第一周的刷题记录与题解分享，如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~

# 上题

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)|简单、高频

### 题目描述

> 反转一个单链表。

### 解题思路

链表入门题，用三个指针：

- 前驱 pre
- 后续 nxt
- 当前 cur

注意：

- 链表指针基本操作
- while 循环什么时候结束

时间复杂度O(n),空间复杂度O(1)

### 代码

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if(!head || !head.next) return head 
    let cur = head, pre = null, nxt
    while(cur != null){
        nxt = cur.next
        cur.next = pre
        pre = cur
        cur = nxt
    }
    return pre
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)|中等、高频

### 题目描述

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

### 解题思路

二叉树经典题目——遍历专题中的层序遍历

常用递归或者队列来写：

#### 递归

将当前节点和所在level、存储结果的数组一起传入递归函数，在递归中取出节点的value，根据level将value存储在对应的位置

#### 队列

队列简单一点，第一步将节点放入队列中，再以 null 为该层结束的标志放入队列中。

每处理一个节点都将其左右节点放入队列中，注意这里要保持左右的顺序

不断出队，当出到 null 就表示该层出完到下一层了，这时再往队列中塞一个 null，作为下一层结束的标志

时间复杂度O(n)，空间复杂度O(n)

### 注意⭐：

注意 JS 数组重置的方式，虽然经测试`arr.length = 0`的速度会比`arr = []`快很多，但是这样是得不到正确答案的，原因是因为：

`arr =[]`创建的是一个新的数组，并为其赋予一个新的引用。其他引用不收影响，仍指向原数组

`arr.length = 0`修改数组本身，就算通过不同的变量访问它，得到的是同一个数组

我还顺手写(水)了篇文章：[JS 基础! |清空数组性能最好的方式是...但能全都用这个吗?](https://juejin.cn/post/7100749681700896804/)

还有就是队列要还有子节点再添加 null 作为标志~ 不然就要掉进循环里咯~

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return[]
    const res = [],
          que = [root, null]
    let     tmpLevel = []
    while(que.length){
        const t = que.shift()
        if(t){
            tmpLevel.push(t.val)
            t.left && que.push(t.left)
            t.right && que.push(t.right)
        }else {// t为null
            res.push(tmpLevel)
            // tmpLevel.length = 0
            // tmpLevel.splice(0,tmpLevel.length)
            tmpLevel = []
            que.length && que.push(null) //注意这里
        }
    }
    return res
};
```



> 也可以每次都存储队列当前的长度作为该层的个数，就不用 null 作为结束标志了，在 while 里面用 for 根据队列长度遍历

## [15. 三数之和](https://leetcode-cn.com/problems/3sum)|中等、高频

### 题目描述

>  给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

### 解题思路

要是直接暴力，那可就是O(n^3)的时间复杂度，没人顶得住~

ok，那我们先剩下一个n，我们可以直接认为 `nums` 中的每一项 `nums[i]` 都能成为 三数中的一数，所以我们现在就可以将问题转换为 `两数之和 = 0 - nums[i]`，那看来模仿第一道题两数之和就能以 O(n) 的复杂度通过了。

no，这道题所求的组数不止是一组，那一道两数之和只要求一组，所以才能找到的时候就 return

还有一个要注意的点：不重复的三元组，怎么样保证不重复？

- 前面循环得到的元素不小于后面循环得到的元素，当然不大于也可以，只要有序就行

ok，我们就选不小于，所以要求最后的三元组`[a, b, c]`，要满足  `a <= b <= c`。那么首先就要先对数组排一下序，排序算法时间复杂度为O(nlogn)

然后再用双指针遍历~

最终时间复杂度为O(n^2)，空间复杂度没什么消耗，主要在于排序算法可能会消耗空间

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    //特例
    if(nums.length < 3) return []
    const res = []
    nums.sort((a, b) => a - b) //升序
    for(let i = 0; i < nums.length; i++){
        if(nums[i] > 0) break; //升序的数组，她大于0就不会后面的加上他能等于0了
        if(i > 0 && nums[i] === nums[i - 1]) continue //一样就跳过，避免重复三元组
        //双指针
        let left = i + 1, right = nums.length - 1
        while(left < right){ // 保证 i < left < right
            if(nums[left] + nums[right] + nums[i] === 0){//找到合适的
                res.push([nums[i], nums[left], nums[right]])
                //跳过重复的
                while(nums[left] === nums[left + 1]) left++
                left++
                while(nums[right] === nums[right + 1]) right--
                right--
             // 不符合的根据情况调整
            }else if(nums[left] + nums[right] + nums[i] > 0){
                right--
            }else left++
        }
    }
    return res
};
```

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)|中等、高频

### 题目描述

> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 k 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

### 解题思路

#### 直接排序

最直观的就是直接排序，然后选择下标为k的就好了

时间复杂度O(nlogn)

#### 小顶堆

维护一个大小为 k 的小顶堆，当堆大小大于 k ，就删除堆顶。等遍历完数组的时候，堆顶就是第k大的元素了

时间复杂度O(nlogk)，空间复杂度O(k)

#### 快速选择

快选有点像快排，就是找基准，然后将大于他的放一边，小于他的放一边。如果大于他的树有 k-1 个，那他自然就是第 k 个大的。

时间复杂度平均为O(n)，最坏为O(n^2)

### 代码

#### 小顶堆

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
class MinHeap {
    constructor() {
        this.heap = [];
    }
    swap(i1, i2) {
        [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
    }
    getParentIndex(i) {
        return (i - 1) >> 1;
    }
    getleftIndex(i) {
        return 2 * i + 1;
    }
    getrightIndex(i) {
        return 2 * i + 2;
    }
    shiftUp(index) {
        if (index === 0) return;
        const parentIndex = this.getParentIndex(index);
        if (this.heap[parentIndex] > this.heap[index]) {
            this.swap(parentIndex, index);
            this.shiftUp(parentIndex);
        }
    }
    shiftDown(index) {
        const leftIndex = this.getleftIndex(index);
        const rightIndex = this.getrightIndex(index);
        if (this.heap[leftIndex] < this.heap[index]) {
            this.swap(leftIndex, index);
            this.shiftDown(leftIndex);
        }
        if (this.heap[rightIndex] < this.heap[index]) {
            this.swap(rightIndex, index);
            this.shiftDown(rightIndex);
        }
    }
    insert(value) {
        this.heap.push(value);
        this.shiftUp(this.heap.length - 1);
    }
    pop() {
        // pop删除数组最后一个元素并返回，赋值给堆顶
        this.heap[0] = this.heap.pop();
        // 对堆顶重新排序
        this.shiftDown(0);
    }
    peek() {
        return this.heap[0];
    }
    size() {
        return this.heap.length;
    }
}

const findKthLargest = (nums, k) => {
    const minHeap = new MinHeap();
    nums.forEach(n => {
        // 将数组元素依次插入堆中
        minHeap.insert(n);
        // 如果堆大小超过k，将堆顶(最小) 的去掉
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    })
    // 返回堆顶，此时就是第k大的元素
    return minHeap.peek();
};
```

#### 快速选择

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const findKthLargest = (nums, k) => {
    const n = nums.length;

    const quick = (l, r) => {
        if (l > r) return;//递归终止条件
        let random = Math.floor(Math.random() * (r - l + 1)) + l; //随机选一个索引
        swap(nums, random, r); //将它和位置r的元素交换，让nums[r]作为基准元素

        //对基准元素进行partition
        let pivotIndex = partition(nums, l, r);
        /*
          partition之后，基准左边的都小于它 右边的都大于它
          基准元素的位置pivotIndex正好是n-k 则找大了第k大的数
          如果n-k<pivotIndex,说明偏大了，去pivotIndex的左边递归查找
          如果n-k>pivotIndex，说明偏小了，去pivotIndex的右边递归查找
        */
        if (n - k < pivotIndex) {
            quick(l, pivotIndex - 1);
        } else {
            quick(pivotIndex + 1, r);
        }
    };

    quick(0, n - 1);//函数开始传入的left=0，right= n - 1
    return nums[n - k]; //最后找到了正确的位置 也就是n-k等于pivotIndex 这个位置的元素就是第k大的数
};

function partition(nums, left, right) {
    let pivot = nums[right];             	//最右边的元素为基准
    let pivotIndex = left;               	//pivotIndex初始化为left
    for (let i = left; i < right; i++) { 	//遍历left到right-1的元素
        if (nums[i] < pivot) {             	//如果当前元素比基准元素小
            swap(nums, i, pivotIndex);       	//把它交换到pivotIndex的位置
            pivotIndex++;                    	//pivotIndex往前移动一步
        }
    }
    swap(nums, right, pivotIndex);       	//最后交换pivotIndex和right
    return pivotIndex;                   	//返回pivotIndex
}

function swap(nums, p, q) {//交换数组中的两个元素
    const temp = nums[p];
    nums[p] = nums[q];
    nums[q] = temp;
}



```



