# 带你用JS 刷高频面试算法题|第一周|okkjoo-leetcodeHot-byJs

`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 每周日更新~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)

这是第一周的刷题记录与题解分享，如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~

# 上题

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)|简单、高频

### 题目描述

> 反转一个单链表。

### 解题思路

链表入门题，用三个指针：

- 前驱 pre
- 后续 nxt
- 当前 cur

注意：

- 链表指针基本操作
- while 循环什么时候结束

时间复杂度O(n),空间复杂度O(1)

### 代码

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if(!head || !head.next) return head 
    let cur = head, pre = null, nxt
    while(cur != null){
        nxt = cur.next
        cur.next = pre
        pre = cur
        cur = nxt
    }
    return pre
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)|中等、高频

### 题目描述

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

### 解题思路

二叉树经典题目——遍历专题中的层序遍历

常用递归或者队列来写：

#### 递归

将当前节点和所在level、存储结果的数组一起传入递归函数，在递归中取出节点的value，根据level将value存储在对应的位置

#### 队列

队列简单一点，第一步将节点放入队列中，再以 null 为该层结束的标志放入队列中。

每处理一个节点都将其左右节点放入队列中，注意这里要保持左右的顺序

不断出队，当出到 null 就表示该层出完到下一层了，这时再往队列中塞一个 null，作为下一层结束的标志

时间复杂度O(n)，空间复杂度O(n)

### 注意⭐：

注意 JS 数组重置的方式，虽然经测试`arr.length = 0`的速度会比`arr = []`快很多，但是这样是得不到正确答案的，原因是因为：

`arr =[]`创建的是一个新的数组，并为其赋予一个新的引用。其他引用不收影响，仍指向原数组

`arr.length = 0`修改数组本身，就算通过不同的变量访问它，得到的是同一个数组

我还顺手写(水)了篇文章：[JS 基础! |清空数组性能最好的方式是...但能全都用这个吗?](https://juejin.cn/post/7100749681700896804/)

还有就是队列要还有子节点再添加 null 作为标志~ 不然就要掉进循环里咯~

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return[]
    const res = [],
          que = [root, null]
    let     tmpLevel = []
    while(que.length){
        const t = que.shift()
        if(t){
            tmpLevel.push(t.val)
            t.left && que.push(t.left)
            t.right && que.push(t.right)
        }else {// t为null
            res.push(tmpLevel)
            // tmpLevel.length = 0
            // tmpLevel.splice(0,tmpLevel.length)
            tmpLevel = []
            que.length && que.push(null) //注意这里
        }
    }
    return res
};
```



> 也可以每次都存储队列当前的长度作为该层的个数，就不用 null 作为结束标志了，在 while 里面用 for 根据队列长度遍历

## [15. 三数之和](https://leetcode-cn.com/problems/3sum)|中等、高频

### 题目描述

>  给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。

### 解题思路

要是直接暴力，那可就是O(n^3)的时间复杂度，没人顶得住~

ok，那我们先剩下一个n，我们可以直接认为 `nums` 中的每一项 `nums[i]` 都能成为 三数中的一数，所以我们现在就可以将问题转换为 `两数之和 = 0 - nums[i]`，那看来模仿第一道题两数之和就能以 O(n) 的复杂度通过了。

no，这道题所求的组数不止是一组，那一道两数之和只要求一组，所以才能找到的时候就 return

还有一个要注意的点：不重复的三元组，怎么样保证不重复？

- 前面循环得到的元素不小于后面循环得到的元素，当然不大于也可以，只要有序就行

ok，我们就选不小于，所以要求最后的三元组`[a, b, c]`，要满足  `a <= b <= c`。那么首先就要先对数组排一下序，排序算法时间复杂度为O(nlogn)

然后再用双指针遍历~

最终时间复杂度为O(n^2)，空间复杂度没什么消耗，主要在于排序算法可能会消耗空间

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    //特例
    if(nums.length < 3) return []
    const res = []
    nums.sort((a, b) => a - b) //升序
    for(let i = 0; i < nums.length; i++){
        if(nums[i] > 0) break; //升序的数组，她大于0就不会后面的加上他能等于0了
        if(i > 0 && nums[i] === nums[i - 1]) continue //一样就跳过，避免重复三元组
        //双指针
        let left = i + 1, right = nums.length - 1
        while(left < right){ // 保证 i < left < right
            if(nums[left] + nums[right] + nums[i] === 0){//找到合适的
                res.push([nums[i], nums[left], nums[right]])
                //跳过重复的
                while(nums[left] === nums[left + 1]) left++
                left++
                while(nums[right] === nums[right + 1]) right--
                right--
             // 不符合的根据情况调整
            }else if(nums[left] + nums[right] + nums[i] > 0){
                right--
            }else left++
        }
    }
    return res
};
```

