# 题解

这里的顺序也是按出现频率的~

## 3. 无重复字符的最长子串

- [ leetcode](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
-

### 解题思路

最长子串——看到这两个关键字你就要想到滑动窗口，那么这道题就是窗口大小无限制的滑动窗口~ 滑动窗口具体控制就是双指针啦

然后需要求得的就是 满足条件（不含重复字符）的窗口中，最大的窗口。

- 用一个 set 存储窗口内的元素
- 当窗口内没有重复字符时就不断地向右边扩张

  - 新的右边界字符存入 set

- 出现重复后就缩小左边的窗口

  - 左边界限向右移动

- 直到最右边界限

### 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    const set = new Set();//记录窗口内元素是否出现过
    let i = 0, j = 0, res = 0;//左右指针、答案
    if(s.length == 0)return 0;//特殊情况
    while(j < s.length){//右边界小于字符串长度
        if(!set.has(s[j])){//set中没有
            set.add(s[j]);//放入set中
            res = Math.max(res, set.size);//看看答案要不要更新
        }else{//set中已经有了
            while(set.has(s[j])){//右移左边界直到没有重复字符
                set.delete(s[i]);
                i++;
            }
            set.add(s[j]);//将右边界字符加入
        }
        j++;//无论如何右边界都是一直走的
    }
    return res
};

```

## 20. 有效的括号

### 解题思路

括号问题，常考的就是栈的运用与操作了~

遍历字符串s

- 拿到左括号：
  - 压入栈中

- 拿到右括号，分类讨论：

  - 栈不为空：

    - 栈顶为对应的左括号：取出栈顶，继续遍历

    - 栈顶不是对应的左括号，`return false`

  - 栈为空: 直接`return false`

遍历完之后，如果栈中还有括号，就说明有左括号没有右括号来与之配对，`return false`



扩展：

也可以通过设置计数器变量存储左右括号出现次数来进行判断



pps：只有一种括号类型的时候才可以使用计数器这个方法:`（（））`，如果不止一种括号，可能就会有些样例过不了，所以这个方法是无效的，例如这种示例4`([)]'`，没有以正确的顺序闭合。



⭐：

- 栈的操作

- JS中的数组中的push、popAPI 就可以模拟栈



### 代码



```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    const stk = [] //数组模拟栈
    const mp = new Map()////对应括号映射
    mp['(']=')'
    mp['{']='}'
    mp['[']=']'
    for(let c of s){
        //拿到左括号
        // if(['(','[','{'].indexOf(c) != -1){
        if(c in mp){
            stk.push(c)
        }else {
            const top = stk.pop()
            if(c !== mp[top]) return false //栈顶不是对应的左括号或者为undefined
        }
    }
    if(stk.length)return false
    return true//一切都恰当
};
```

![image-20220516171807311](https://gitee.com/okkjoo/image-bed/raw/master/imgs/image-20220516171807311.png

## 4. 寻找两个正序数组的中位数

### 解题思路

#### 不完全暴力

双指针分别从两个数组A、B起始位开始

1. 如果 `A[i] <= B[j]` , 则把 `A[i]` 放入新的数组中,i 往后移一位,即 i++ .

2. 如果` A[i] > B[j] `, 则把 `B[j]` 放入新的数组中,j 往后移一位, 即 j++ .

3. 计数器cnt，每次任意指针++时都++

4. 重复，直到 `cnt == (n+1)/2`，即到达中位数之地



虽然比起完全合并优化了一些，小于`O(n+m)`，但没有达到`O(log(n+m))的要求`

#### 二分查找

⭐：

1. 两个有序数组合并后，一个数组中本身的相对位置并不会变

2. 有序——二分查找

3. 对小的那个数组进行二分，确定一个 i，自然就能得到 j，因为最后的找到中位数的情况就是 `i(i+1) + (j+1) == (m + n + 1) / 2`

其中m、n分别两个数组的大小

具体来说，就是最后的情况满足`len(Aleft)+len(Bleft)=(m+n+1)/2`，并且满足` (maxLeftA <= minRightB && maxLeftB <=minRightA)`，也就是最终为下图这样的形式：

![image.png](https://pic.leetcode-cn.com/1652693635-ONmbLU-image.png)



那么要怎么到达这样的形式呢

对小的那一个数组进行二分查找，不满足就调整，具体怎么调整看代码，直到调整到满足条件



最终复杂度为`O(min(m,n))`

 

![image.png](https://gitee.com/okkjoo/image-bed/raw/master/imgs/1652693618-TwYBOu-image.png)

### 代码



```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    //对数组长度较短的那个进行二分查找操作
    nums1.length > nums2.length && ([nums1, nums2] = [nums2, nums1])
    const m = nums1.length, 
          n = nums2.length
    let low = 0, high = m 
    //二分
    while(low <= high){
        const i = low + Math.floor((high - low) / 2), //i:数组A中 minRightA 的下标
              j = Math.floor((m + n + 1) / 2) - i     //j:数组B中 minRightB 的下标  
        //这里注意特判，在边界的时候为了满足下面的条件，left的就是负无穷，right那头就是正无穷
        const maxLeftA = i === 0 ? -Infinity : nums1[i-1],
              minRightA = i === m ? Infinity : nums1[i]     
        const maxLeftB = j === 0 ? -Infinity : nums2[j - 1],
              minRightB = j === n ? Infinity : nums2[j]     
        //进行判断
        if(maxLeftA <= minRightB && maxLeftB <= minRightA){
            return (m + n) & 1 //m+n 的奇偶情况分量讨论
                ? Math.max(maxLeftA, maxLeftB)
                : (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB))/2
        }//不满足的话就要根据情况调整 low / high 指针
        else if(maxLeftA > minRightB){
            high = i - 1
        }else {
            low = low + 1
        }
    }
};
```

