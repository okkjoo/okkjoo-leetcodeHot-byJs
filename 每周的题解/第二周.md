# 带你JS 刷高频面试算法题|第一周|okkjoo-leetcodeHot-byJs

`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 每周日更新~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)

这是第一周的刷题记录与题解分享，如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~

# 上题

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)|简单、高频

### 题目描述

> 反转一个单链表。

### 解题思路

链表入门题，用三个指针：

- 前驱 pre
- 后续 nxt
- 当前 cur

注意：

- 链表指针基本操作
- while 循环什么时候结束

时间复杂度O(n),空间复杂度O(1)

### 代码

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if(!head || !head.next) return head 
    let cur = head, pre = null, nxt
    while(cur != null){
        nxt = cur.next
        cur.next = pre
        pre = cur
        cur = nxt
    }
    return pre
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)|中等、高频

### 题目描述

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

### 解题思路

二叉树经典题目——遍历专题中的层序遍历

常用递归或者队列来写：

#### 递归

将当前节点和所在level、存储结果的数组一起传入递归函数，在递归中取出节点的value，根据level将value存储在对应的位置

#### 队列

队列简单一点，第一步将节点放入队列中，再以 null 为该层结束的标志放入队列中。

每处理一个节点都将其左右节点放入队列中，注意这里要保持左右的顺序

不断出队，当出到 null 就表示该层出完到下一层了，这时再往队列中塞一个 null，作为下一层结束的标志

时间复杂度O(n)，空间复杂度O(n)

### 注意⭐：

注意 JS 数组重置的方式，虽然经测试`arr.length = 0`的速度会比`arr = []`快很多，但是这样是得不到正确答案的，原因是因为：

`arr =[]`创建的是一个新的数组，并为其赋予一个新的引用。其他引用不收影响，仍指向原数组

`arr.length = 0`修改数组本身，就算通过不同的变量访问它，得到的是同一个数组

我还顺手写(水)了篇文章：[JS 基础! |清空数组性能最好的方式是...但能全都用这个吗?](https://juejin.cn/post/7100749681700896804/)

还有就是队列要还有子节点再添加 null 作为标志~ 不然就要掉进循环里咯~

### 代码

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return[]
    const res = [],
          que = [root, null]
    let     tmpLevel = []
    while(que.length){
        const t = que.shift()
        if(t){
            tmpLevel.push(t.val)
            t.left && que.push(t.left)
            t.right && que.push(t.right)
        }else {// t为null
            res.push(tmpLevel)
            // tmpLevel.length = 0
            // tmpLevel.splice(0,tmpLevel.length)
            tmpLevel = []
            que.length && que.push(null) //注意这里
        }
    }
    return res
};
```



> 也可以每次都存储队列当前的长度作为该层的个数，就不用 null 作为结束标志了，在 while 里面用 for 根据队列长度遍历

