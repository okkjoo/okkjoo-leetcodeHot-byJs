> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 每周一更新~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~



这是第四周的刷题记录与题解分享

---

# 上题

## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)|简单|二叉树入门题

### 题目描述

> 给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

### 解题思路

二叉树入门题目

分享一下自己怎么记前中后序遍历是咋样的，前中后，就对应 root 的位置。比如这里的是中序遍历，那就是左节点、root、右节点的顺序。

很简单，递归的时候按顺序来就好了，先左然后处理中，最后右

```js
// @lc code=start
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
	const res = [];
	const inorder = root => {
		if (!root) return;
		inorder(root.left);
		res.push(root.val);
		inorder(root.right);
	};
	inorder(root);
	return res;
};
```

## [剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)|简单|递归|记忆化搜索|dp

### 题目描述

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> >  F(0) = 0,   F(1) = 1
> > F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> > 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>

### 解题思路

#### 递归

一眼看上去，不就是递归就好了，直接按照定义写一个函数开始递归。但是这当然不会考那么简单，很容易发现这里面充满了重复的子问题，多次递归中都会重复计算相同的某个`F(n)`

#### 记忆化

那么我们将重复的直接存下来不就好了，创建一个数组来存储计算过的值。每次需要对应的值时先查找是否计算过，计算过就直接用就好了。没计算过再进行计算

#### dp

然后我们又发现，这个定义不就是 dp 里面的状态转移方程嘛

- `dp[i]`表示其代表 斐波那契 第i个数字
- 状态转移方程就是定义
- 初始化 前两个数字就好了
  - 第0个就是0

甚至因为不需要存储以前的数据，实际上只需要三个变量就可以完成了，空间复杂度O(1)



#### 求余

这里要注意的是，他还说了需要取模，取模其实就是求余~  他说对结果取模，你可不能真到最后返回结果的时候取模，要在每一步 sum 发生变化的时候取模

### 代码

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
	let a = 0,
		b = 1,
		c = 0;
	for (let i = 0; i < n; i++) {
		c = (a + b) % 1000000007;
		a = b;
		b = c;
	}
	return a;
};
```



## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)|简单|二叉树|递归

###  题目描述

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。

### 解题思路

解决二叉树问题最好先想递归方法，真的好使，一个DFS就好了

不过可以扩展一下思路，求深度 用 队列来 BFS  也是不错的。

1. 用特殊元素划分每一层
2. 或者在进入下一层之前记录当前队列的长度

### 代码

```js
/**
 * DFS
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
	if (!root) return 0;
	if (!root.left && !root.right) return 1;
	return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
```

```js
/**
 * BFS
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
	if (!root) return 0;
	if (!root.right && !root.left) return 1;
	let cur = root;
	const que = [root, null];
	let level = 1;
	while ((cur = que.shift()) !== undefined) {
		if (cur === null) {
			if (que.length === 0) return level;
			level++;
			que.push(null);
			continue;
		}
		cur.left && que.push(cur.left);
		cur.right && que.push(cur.right);
	}
};
```

